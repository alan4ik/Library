#include <openssl/evp.h>
#include <openssl/pem.h>
#include <string>
#include <stdexcept>

std::tuple<std::string, size_t, bool> encryptRSAWithKey(const std::string& publicKey, const std::string& message, size_t messageLength) {
    std::string encryptedMessage;
    size_t encryptedMessageLength = 0;
    bool error = false;

    // Создание BIO для чтения открытого ключа
    BIO* bioPublicKey = BIO_new_mem_buf(publicKey.data(), publicKey.length());
    if (!bioPublicKey) {
        error = true;
        return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
    }

    // Импорт открытого ключа
    EVP_PKEY* rsaPublicKey = PEM_read_bio_PUBKEY(bioPublicKey, NULL, NULL, NULL);
    BIO_free(bioPublicKey);
    if (!rsaPublicKey) {
        error = true;
        return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
    }

    // Создание контекста шифрования
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        error = true;
        EVP_PKEY_free(rsaPublicKey);
        return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
    }

    // Установка открытого ключа для шифрования
    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, NULL, NULL) != 1 || EVP_EncryptInit_ex(ctx, NULL, NULL, EVP_PKEY_get0_RSA(rsaPublicKey), NULL) != 1) {
        error = true;
        EVP_CIPHER_CTX_free(ctx);
        EVP_PKEY_free(rsaPublicKey);
        return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
    }

    // Расчет размера буфера для зашифрованного сообщения
    int maxEncryptedSize = EVP_PKEY_size(rsaPublicKey);
    encryptedMessage.resize(maxEncryptedSize);

    // Шифрование сообщения
    int actualEncryptedSize = 0;
    if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(encryptedMessage.data()), &actualEncryptedSize,
                          reinterpret_cast<const unsigned char*>(message.data()), messageLength) != 1) {
        error = true;
        EVP_CIPHER_CTX_free(ctx);
        EVP_PKEY_free(rsaPublicKey);
        return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
    }

    // Завершение шифрования
    int finalEncryptedSize = 0;
    if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(encryptedMessage.data()) + actualEncryptedSize, &finalEncryptedSize) != 1) {
        error = true;
    }

    encryptedMessageLength = actualEncryptedSize + finalEncryptedSize;

    // Очистка ресурсов
    EVP_CIPHER_CTX_free(ctx);
    EVP_PKEY_free(rsaPublicKey);

    return std::make_tuple(encryptedMessage, encryptedMessageLength, error);
}

// Пример использования
std::string publicKey = "-----BEGIN PUBLIC KEY-----\n"
                        "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQZq6TWR0xNz5EZWY2uzmB8tU2\n"
                        "bCunFX6Qkl+pEtjY4Z1UGyjDWxZ9SS2x7fl1GBRQ9LV/L6C1Yf8yXoBuH8/lLQQP\n"
                        "PE+hyj9MLZvQVeqj8u6cdEONeBSN3FxlkMkxtQfrFXamX3JX+jutkZcDJXMXX9Ee\n"
                        "4xyESn0K7P/nt7v86QIDAQAB\n"
                        "-----END PUBLIC KEY-----";

std::string message = "Hello, World!";
size_t messageLength = message.length();

std::tuple<std::string, size_t, bool> result = encryptRSAWithKey(publicKey, message, messageLength);
std::string encryptedMessage = std::get<0>(result);
size_t encryptedMessageLength = std::get<1>(result);
bool error = std::get<2>(result);

if (error) {
    throw std::runtime_error("Error occurred during RSA encryption.");
}
