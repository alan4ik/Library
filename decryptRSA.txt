#include <openssl/evp.h>
#include <openssl/pem.h>
#include <string>
#include <stdexcept>

std::tuple<std::string, size_t, bool> decryptRSAWithKey(const std::string& privateKey, const std::string& encryptedMessage, size_t encryptedMessageLength) {
    std::string decryptedMessage;
    size_t decryptedMessageLength = 0;
    bool error = false;

    // Создание BIO для чтения закрытого ключа
    BIO* bioPrivateKey = BIO_new_mem_buf(privateKey.data(), privateKey.length());
    if (!bioPrivateKey) {
        error = true;
        return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
    }

    // Импорт закрытого ключа
    EVP_PKEY* rsaPrivateKey = PEM_read_bio_PrivateKey(bioPrivateKey, NULL, NULL, NULL);
    BIO_free(bioPrivateKey);
    if (!rsaPrivateKey) {
        error = true;
        return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
    }

    // Создание контекста расшифровки
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        error = true;
        EVP_PKEY_free(rsaPrivateKey);
        return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
    }

    // Установка закрытого ключа для расшифровки
    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, NULL, NULL) != 1 || EVP_DecryptInit_ex(ctx, NULL, NULL, EVP_PKEY_get0_RSA(rsaPrivateKey), NULL) != 1) {
        error = true;
        EVP_CIPHER_CTX_free(ctx);
        EVP_PKEY_free(rsaPrivateKey);
        return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
    }

    // Расчет размера буфера для расшифрованного сообщения
    int maxDecryptedSize = encryptedMessageLength;
    decryptedMessage.resize(maxDecryptedSize);

    // Расшифровка сообщения
    int actualDecryptedSize = 0;
    if (EVP_DecryptUpdate(ctx, reinterpret_cast<unsigned char*>(decryptedMessage.data()), &actualDecryptedSize,
                          reinterpret_cast<const unsigned char*>(encryptedMessage.data()), encryptedMessageLength) != 1) {
        error = true;
        EVP_CIPHER_CTX_free(ctx);
        EVP_PKEY_free(rsaPrivateKey);
        return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
    }

    // Завершение расшифровки
    int finalDecryptedSize = 0;
    if (EVP_DecryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(decryptedMessage.data()) + actualDecryptedSize, &finalDecryptedSize) != 1) {
        error = true;
    }

    decryptedMessageLength = actualDecryptedSize + finalDecryptedSize;

    // Очистка ресурсов
    EVP_CIPHER_CTX_free(ctx);
    EVP_PKEY_free(rsaPrivateKey);

    return std::make_tuple(decryptedMessage, decryptedMessageLength, error);
}

// Пример использования
std::string privateKey = "-----BEGIN PRIVATE KEY-----\n"
                         "MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCv2QV/y0eq2n+8\n"
                         "nH5UTd1MLjGS7jwVDr6qTmUpnR1fz3y8+31i8NR58c/eqS2RyBbPC3W9XAsw/YC8\n"
                         "RiOyPtuXzWnXv+eVmIKRe6INJHN5OYFb34AUSVXJ/2VUTSGgHsAjOydKwq2gm+7N\n"
                         "JHc9OlEJd3PLI2Rm9yAE8l4WFw9Zj2zAPnZwjz4+6iAA2HLIbMqZBYYOdfHn2FKh\n"
                         "lZMa9DK3/UPxyP3xzSDu27Kasr8TqY3Cey3fC85cCrMhxWhrTLuYfgjruxYSKl3u\n"
                         "CpGyKvnn3wbTGw/7Pp7znqQChVohzQx4o4ewYjq/U5swCqF/fHdHECvyaaiH9fDV\n"
                         "DvzTM/LRAgMBAAECggEBAI3SsPqJdQQHsF4J1m70NoJXhbm28Dk0xEM5KNS6TuyI\n"
                         "CTQ7TnIewieU0Z9x6kGcUsE46I4jKRLGd+ruGYu0rM4FgJGdQf+WwXZqYj8tA2cq\n"
                         "OgRA0QRg20j4/F5PRf4UZDmqx+cABiJh4cGq3A2gld1axcMUDkPWfQByCN9R3lYw\n"
                         "1ZMbex4zDfG8O07ynznn2T2SfOgu27Aey1o3G1B1LVsRWfWJ7A7c7j8LX0wSGBi4\n"
                         "PcnYoQ0WtnM0qURwotMKH8NapbmkK2UZUzqXSl6SZkjs6WjL7HdmhO/K5kqiwu6H\n"
                         "C64XrBmAVIQWXiNU/jBaJP3IQoLfT3M7pIr6TGOV7gECgYEA+7spfMHPj+EEFLXN\n"
                         "TSW2O9n2/DZmcsOlQrHK9WTDKkxrn8CzD/g5Wub6B/rBN9kG5eZkD06M0zk6Ig5q\n"
                         "zn2/qviMAZwUTZVZqfLW0YPJ/8Fmk+1/3H2sYK2Xjt8XDTUSL0gtqqFwVuJcELik\n"
                         "U85yxOyxY5C8CqYksX1qBUxxh10CgYEAxVYIfL5x8iSSxk1DdC0B9t55uJQ0WNTY\n"
                         "nHn/BTDpWcK4ADgJL1XCv7sMYzy62DjPvrPz1U6pBVew+XTfwAq1inr6XAdrdyl3\n"
                         "J52C5l5cNHEtLVLcRKUZBZ1ViBLK3zK49c5WzxWvV8zLxxvB5TINaAHL4ANHfV/A\n"
                         "OqRy9ph6TsECgYAnvDK8dLp8mkhBDbTluhLz/2iPhD1GzSk2pKxxaEiJrA/9LPUG\n"
                         "Kr3EoFlSz+n80O3fX/FtMz8FSFF8Z1HgkQnbyV7meoEzE+4Eo9ey3a9X0gl6XXRW\n"
                         "fKKRA7Yo1hS6icjshW+2Zy0pS5Pdc07vQH3P/e6DqLAAUCfl/m8yeAD5TQKBgDWR\n"
                         "z97FOc/QrrQc6qTqyCf8LYa9yr8dsNTT3w7j4awH6TKaSvM5gNchqzDXBMLKcoWp\n"
                         "lGKOl0Q16lIMZbH7BaC9KB7UvAJy8vlY/dRAgUfUJ2i3K60poy4zOn6oA84BgnEd\n"
                         "6VTQlACmR8rgAn9du9EhBXz5jDz5/mqalOD5oQOpAoGAUhPWsWjbVzLzHeLg4j5B\n"
                         "DGB1Wv+n0xl2TVglOdC1pELUd6ioKgkKnjvGmiB9Rf+ZL9UdqfJfwdlqOh4P8Fy9\n"
                         "kk1xyB/LVSYBEW/smdYoE/xNOAf2Lj1BqTX3O7bzC5aTG9z+TIht69CqoEe5ADSE\n"
                         "D7OcdW6NMTFxvraG+/f40P0=\n"
                         "-----END PRIVATE KEY-----";

std::string encryptedMessage = "Rd70CvAJmmh3j1n1Uv9bUcGpU7Mxqvc8ysMfbOyI9+o96OaCKwNYCqUtFj3aPjkg\n"
                              "cEt1U8aYlFYq57l0uIOrC29dQENvVLKbD5yZjKhzIT9n+ljWfKsRUT0eFnQckWco\n"
                              "47JG4gPcpxRkPmkfY6EL2ckPrjcEF1dwJkyPO8KprD4=";

size_t encryptedMessageLength = encryptedMessage.length();

std::tuple<std::string, size_t, bool> result = decryptRSAWithKey(privateKey, encryptedMessage, encryptedMessageLength);

std::string decryptedMessage = std::get<0>(result);
size_t decryptedMessageLength = std::get<1>(result);
bool error = std::get<2>(result);

if (!error) {
    // Расшифрованное сообщение
    std::cout << "Decrypted Message: " << decryptedMessage << std::endl;
    // Длина расшифрованного сообщения
    std::cout << "Decrypted Message Length: " << decryptedMessageLength << std::endl;
} else {
    // Обработка ошибки
    std::cout << "Error occurred during decryption." << std::endl;
}
