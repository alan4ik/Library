#include <openssl/evp.h>
#include <openssl/pem.h>

std::pair<std::string, std::string> generateRSAKeyPair() {
    std::pair<std::string, std::string> keyPair;

    // Инициализация контекста EVP
    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, NULL);
    EVP_PKEY* keypair = NULL;

    // Генерация ключевой пары RSA
    if (EVP_PKEY_keygen_init(ctx) <= 0 || EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048) <= 0 ||
        EVP_PKEY_keygen(ctx, &keypair) <= 0) {
        // Обработка ошибки
        EVP_PKEY_CTX_free(ctx);
        return keyPair;
    }

    // Создание BIO для записи открытого ключа
    BIO* bioPublicKey = BIO_new(BIO_s_mem());
    if (PEM_write_bio_PUBKEY(bioPublicKey, keypair) <= 0) {
        // Обработка ошибки
        BIO_free_all(bioPublicKey);
        EVP_PKEY_free(keypair);
        EVP_PKEY_CTX_free(ctx);
        return keyPair;
    }

    // Получение данных из BIO для открытого ключа
    BUF_MEM* memPublicKey;
    BIO_get_mem_ptr(bioPublicKey, &memPublicKey);
    std::string publicKey(memPublicKey->data, memPublicKey->length);
    BIO_free_all(bioPublicKey);

    // Создание BIO для записи закрытого ключа
    BIO* bioPrivateKey = BIO_new(BIO_s_mem());
    if (PEM_write_bio_PrivateKey(bioPrivateKey, keypair, NULL, NULL, 0, NULL, NULL) <= 0) {
        // Обработка ошибки
        BIO_free_all(bioPrivateKey);
        EVP_PKEY_free(keypair);
        EVP_PKEY_CTX_free(ctx);
        return keyPair;
    }

    // Получение данных из BIO для закрытого ключа
    BUF_MEM* memPrivateKey;
    BIO_get_mem_ptr(bioPrivateKey, &memPrivateKey);
    std::string privateKey(memPrivateKey->data, memPrivateKey->length);
    BIO_free_all(bioPrivateKey);

    EVP_PKEY_free(keypair);
    EVP_PKEY_CTX_free(ctx);

    keyPair.first = publicKey;
    keyPair.second = privateKey;

    return keyPair;
}

// Пример использования
std::pair<std::string, std::string> rsaKeyPair = generateRSAKeyPair();
std::string publicKey = rsaKeyPair.first;
std::string privateKey = rsaKeyPair.second;
