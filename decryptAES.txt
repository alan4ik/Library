#include <openssl/evp.h>
#include <openssl/aes.h>
#include <string>
#include <stdexcept>

std::pair<std::string, size_t> decryptAES(const std::string& encryptedMessage, size_t encryptedMessageLength) {
    const int keyLength = 32; // Длина ключа (в байтах) для AES-256
    const int ivLength = AES_BLOCK_SIZE; // Длина вектора инициализации (IV) (в байтах)

    // Создание ключа и вектора инициализации
    unsigned char key[keyLength];
    unsigned char iv[ivLength];
    // Заполнение key и iv данными, соответствующими вашему случаю

    // Создание контекста дешифрования
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create decryption context");
    }

    // Установка параметров дешифрования
    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize decryption");
    }

    // Вычисление размера расшифрованного сообщения
    int decryptedSize = encryptedMessageLength;
    std::string decryptedMessage(decryptedSize, '\0');
    int actualDecryptedSize = 0;

    // Расшифровка сообщения
    if (EVP_DecryptUpdate(ctx, reinterpret_cast<unsigned char*>(decryptedMessage.data()), &actualDecryptedSize,
                          reinterpret_cast<const unsigned char*>(encryptedMessage.data()), encryptedMessageLength) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to decrypt message");
    }

    // Завершение расшифровки
    int finalDecryptedSize = 0;
    if (EVP_DecryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(decryptedMessage.data()) + actualDecryptedSize,
                            &finalDecryptedSize) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to finalize decryption");
    }

    EVP_CIPHER_CTX_free(ctx);

    decryptedSize = actualDecryptedSize + finalDecryptedSize;

    return std::make_pair(decryptedMessage, decryptedSize);
}

// Пример использования
std::string encryptedMessage = "your_encrypted_message";
size_t encryptedMessageLength = encryptedMessage.length();

try {
    std::pair<std::string, size_t> decryptedData = decryptAES(encryptedMessage, encryptedMessageLength);
    std::string decryptedMessage = decryptedData.first;
    size_t decryptedMessageLength = decryptedData.second;
    // Дальнейшая обработка расшифрованного сообщения
} catch (const std::exception& e) {
    // Обработка ошибки
}
